The way the pins are ordered is pretty interesting. Each pin seems to have a corresponding unique
value in the memory. There is a memory array called pins which seems to store the information
about whether the pins are open or not. These pin values are then evaluated by the individual 
pins with their unique values.

Pin order: 3 - 1 - 5 - 2 - 4

SAR vs SHR & SAL vs SHL:
	the arithmetic versions (A) retain the sign.

Pin 3:

	x^(0xdeadbeef) = 0x13371337

	x^(11011110101011011011111011101111) = 00010011001101110001001100110111

	x -> Number for unlocking the pin

	on solving we get x = 11001101100110101010110111011000
	i.e. x = 3449466328 

Pin 1:

	Initially at the start of the dissassembly, we see:
		mov     byte [rbp-0xe {var_16}], 0x3e
		mov     byte [rbp-0xd {var_15}], 0x57
		mov     byte [rbp-0xc {var_14}], 0x81
		mov     byte [rbp-0xb {var_13}], 0xd3
		mov     byte [rbp-0xa {var_12}], 0x25
		mov     byte [rbp-0x9 {var_11}], 0x93
	where we move the values 0x3e, 0x57, 0x81, 0xd3, 0x25 and 0x93
	into consecutive byte locations.

	We take a number from the user...

	We see that in the final compare statement we compare the value
	at rbp-0x16 with 0xee, so we go back from here to the previous
	segment where we xor the rbp-0x16 value with the various values
	we stored earlier. This algorithm is developed
	(unknown value 6)^(0x93) = (0xee)
	(unknown value 5)^(0x25) = (unknown value 5)
	...
	...
	(unknown value 0)^(0x3e) = (unknown value 1)

	going through this algorithm with a script we get that
	(unknown value 0) = 99, which is the number we have to input.

Pin 5:

	This one was too easy, they gave a seed for seeding the random numbers
	seed: 0x42424242 -> in decimal -> 1111638594
	I wrote a small C script which took the same seed to generate the solution
	which was 1413036362 (how does seeding work, and why does it produce different
	outputs in C and Python)

Pin 2:

	We use the current system time as the seed here which is printed out onto the
	screen. Use this as the seed in the scripts given and you get
	your answer.

Pin 4:

	You are asked to enter a sentence, call it S.
	A weird value G is calculated with S and the following operations are performed:

	N = 0
	for i in S:
		N = N + ((S[i])^G)
	if N == 0x123:
		we have solved the problem
	
	what is G:
		G = number generated by the math (check out brute.c)
		r = random number generated at the start of *this* code
		0x123 = 291 (decimal)
		So the "favorite sentence" depends totally on the seed used which is the system time we pick pin 2 at.
		
		We now have to bruteforce to find what S is.
		Say we're looking for a 4 letter sentence then we can partition 0x123
		which is 291 in decimal to 96 + 96 + 96 + 3
		i.e. of the form: (291 - 3k)/3 + (291 - 3k)/3 + (291 - 3k)/3 + 3k
		Then we can run a bruteforce algorithm that finds two letters
		a & b, where a^(G) = (291 - 3k)/3 and b^(G) = 3k.

		If we find no solution, then we can change forms like:
		96 + 96 + 94 + 4, 96 + 95 + 95 + 5, etc...

		Luckily, In most of the cases I tried. The first form:
		96 + 96 + 96 + 3, always seems to work. So I wrote the script just for that
		one certain form. Lazy :P
		Other people have pointed out in their writeups that the values of G are
		bounded between 0x41 and 0x4a, I too have observed this and it seems rather
		correct. The form produces valid ascii sentences for these values:
		[{'0x41': '!!!B'}, {'0x42': '"""A'}, {'0x43': '###@'}, {'0x44': '$$$G'},
		{'0x45': '%%%F'}, {'0x46': '&&&E'}, {'0x47': "'''D"}, {'0x48': '(((K'},
		{'0x49': ')))J'}, {'0x4a': '***I'}]

		So this really is a valid solution for all cases :P
