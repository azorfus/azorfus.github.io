---
layout: post
title:  "Simple NX Bypassing (Draft) (Binary Exploitation)"
date:   2024-04-XX 00:XX:XX +0530
categories: Binary Exploitation
---

NX - No eXecute is a feature that was introduced which would make certain
portions of the stack non-executable, i.e. You couldn't execute on the portions
of the stack marked with an NX bit. This makes it so that we cannot perform a 
normal/usual stack overflow attack. 
In my searching I found that there are two ways for bypassing NX, Lets call
them: kill the NX bit and dodge the NX bit.
Much of what we do is "dodging the NX bit". Killing the NX bit is where you
invoke special function calls (?) to write over/delete the NX bits which mark the
stack non-executable.
I am using the "dodge" method since that's what I need to learn for the next crackmes.one problem.

ASLR is disabled, as bypassing ASLR is for another day :P
I use python2 extensively due to its ability to use latin-1 encoding.

This is the code for the binary we're about to exploit:

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
	
int main()
{
	char buffer[40];
	printf("Buffer: %p\n", &buffer); // For debugging purposes
	gets(buffer);
	printf(buffer);

	return 0;
}
```

As far as I've seen there are two ways of exploiting, One is done when the
binary is dynamically linked, We reach into the libc library which holds
system() to get a shell for example. 
Incase of statically linked binaries, Its not always the case to have system()
statically linked with the binary, So instead we invoke a syscall for execve()
inorder to get a shell, Which should work in both settings (static & dynamic)
I'll be doing it with the execve method in a statically linked binary first
and then do it with the system() method in a dynamically linked binary.

execve() method (I've not really researched much into this, hence the short write-up):

We'll compile it with no stack protection and with debugging options:
	
	gcc -Wall -fno-stack-protector -static -znoexecstack -g overflow.c -o overflow

	Wall: Provides a comprehensive set of warnings, covering a wide range
	      of potential issues.

	static: Statically links the binary intead of using runtime libraries.
	        Disables PIE and makes full RELRO -> partial RELRO (how?)
			(This option does not let us use the libc->system() method as
			system() is not statically linked due to it having no use.)

	fno-stack-protector: This eliminates __stack_check_fail calls in the code
	                     If you've reverse engineered many binaries you would've
						 seen this being called everywhere.
						 It exists so that if the stack ever overflows, execution
						 is immediately terminated. (We don't want that)
	
	znoexecstack: No eXecute

	g: Makes the binary debuggable

What we are doing:
	
	We hijack the return address stored after our buffer in the stack that points
	to clean-up instructions in __libc_start_call_main that are triggered once we
	return from main(). We replace this address with ones produced by ROPGadget
	which conveniently gives us all the "gadgets" that are required for us to get
	a shell, Unfortunately for some reason I couldn't get it to give me a shell, 
	Even though the command was being executed. /bin/ls worked successfully when
	/bin/sh did not. (Can someone point out why :/)

Functioning: 

	int execve(char const *path, char const *argv[], char const *envp[]);

	We give execve() its parameters in the four regular purpose registers
	eax, ebx, ecx and edx. Where eax is syscall number, ebx holds "/bin/ls",
	ecx (pointer to array of string pointers representing argv) and edx 
	(pointer to array of string pointers representing envp are both 0 for our purposes.

Generating ROP chain:
	
	ROPgadget --binary <binary_name> --ropchain

	ROPgadget provides a ROP chain at the end of the output of this command, copy paste
	it into your own exploit for it to work with your binary.

All files including the binary, binary source, exploit.py and the payload can be found [here](https://github.com/azorfus/azorfus.github.io/tree/blog/resources/nx_bypassing_independent/nx_bypass_execve).

libc system() method (primary idea):
