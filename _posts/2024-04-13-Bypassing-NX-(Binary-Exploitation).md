---
layout: post
title:  "Bypassing NX"
date:   2024-04-13 00:21:00 +0530
categories: Binary Exploitation and Reversing
---

NX - No eXecute is a feature that was introduced which would make certain
portions of the stack non-executable, i.e. You couldn't execute on the portions
of the stack marked with an NX bit. This makes it so that we cannot perform a 
normal/usual stack overflow attack. 
In my searching I found that there are two ways for dealing with NX, Lets call
them: kill the NX bit and dodge the NX bit.
Much of what we do is "dodging the NX bit". Killing the NX bit is where you
invoke special function calls (?) to write over/delete the NX bits which mark the
stack non-executable.

Our goal in this crackmes is to bypass/dodge NX
All files associated to the crackmes can be found here. Click here for the crackmes
site.

ASLR is disabled.
/proc/sys/kernel/randomize_va_space set the value in here to 0 to disable ASLR

Looking at the disassembly we see that there is a call to read() inorder to get 
an input from the user. read() is almost the same as gets(), read() is used to 
get a byte stream, whereas gets() is more appropriate for a text stream.
This makes read() as dangerous as gets(). Reading the minimal assembly we can
see that the binary was compiled from code like such:
```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main()
{
  char buffer[40];
  printf("Buffer: %p\n", &buffer); // For debugging purposes
  gets(buffer);
  printf(buffer);

  return 0;
}
```
A classic stack overflow is where you'd take advantage of this unguarded read 
into stack to over-write and execute shellcode, but since we can't execute code
on the stack, We'll call an internal function from libc - system().
libc is included almost with all binaries, it contains important functions like
puts(), gets(), exit() and so on. When dynamically linked we can access system()
When we call system() with the argument "/bin/sh" we evoke a shell.

This specific type of expoit is known as return_to_libc.

I'm using pwntools to interact with the binary, Inorder to provide the shell
that we evoke with a stdin and stdout with ease. You could do it without
the pwntools and feed it just the payload but I doubt you'd get the shell even
if it works.

Lets first understand how function calls work in the low level world.



Memory during run time looks something like this:

	|||||||||||| buffer |||||| RIP || Stack -> ....
	                            |
	                    Top of the stack

We overflow buffer inorder to overwrite the return instruction pointer of main
which is initially pointing to an exit functon somewhere. 




Once the stack frame is initialized, we perform our instructions and then we
have to perform clean up, which is where leave and retn come into place.

leave is a sort of macro for these operations:

	mov rsp, rbp  ---> Moves the stack pointer back to base, destroying /
                       deallocating memory.

	pop rbp       ---> restores value of rbp from the top of the stack.

retn:
	
	pop rip
	jmp rip

The value ADR is loaded into rip here.
